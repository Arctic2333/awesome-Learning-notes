# unit 3

## 内存中字的存储

在内存存储时，由于内存单元是字节单元（一个单元存放一个字节），则**一个字要用两个地址连续的内存单元来存放。**

字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。**高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。**

起始地址为0的字单元存放4E20H 则 20存放在0号单元（低位字节），4E存放在1号单元（高位字节）。

- 起始地址为N的字单元简称为N地址字单元。
- 任何两个连续的内存单元，N号单元和N+1号单元，可以看成两个内存单元，也可以看作一个地址为N的字单元的高位字节和低位字节单元。

## DS和[address]

8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。

数据从内存单元到寄存器的格式： **mov 寄存器名,内存单元地址(用“[]”括起来)**

从寄存器到内存单元的格式：**mov 内存单元地址，寄存器名**

**[]**表示一个内存单元，“【】“中的数字表示内存单元的偏移地址。我们知道只有偏移地址是不能确定一个内存单元的。所以执行时**8086CPU自动取DS中的数据为内存单元的段地址。**

**8086CPU不支持数据直接送入段寄存器的操作。**只能用一个寄存器作为中转，**先将数据送入一个一般寄存器**，如bx，**再将bx中的数据送入DS。**

## 字的传送

8086是16位结构。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。

如：

![](https://img-blog.csdnimg.cn/20200115121525127.PNG)

![](https://img-blog.csdnimg.cn/20200115121547102.PNG)

- **mov，add，sub 指令中[num] ：num都是字单元的起始地址，也就是低位字节，num+1是高位字节，num和num+1共同构成一个数据。**

## mov、add、sub指令

mov 寄存器，数据       比如：mov ax，8

mov 寄存器，寄存器	比如：mov ax，bx

mov 寄存器，内存单元	比如: mov ax,[0]

mov 内存单元，寄存器   mov  [0],ax

mov 段寄存器，寄存器  mov cs,ax

mov 寄存器，段寄存器  mov ax,cs

mov 内存单元，段寄存器  mov [0],cs

- **add,sub指令与mov一样，也可以有以上几种形式，但是不可以对段寄存器进行操作。**

## 数据段

可以将一组长度为N（N<=68kb）、地址连续、起始地址为16的倍数的内存单元当作**专门存储数据的内存空间**，从而定义一个数据段。

具体操作:用ds存放数据段的段地址，根据需要，用相关指令访问数据段的具体单元。

![](https://img-blog.csdnimg.cn/20200115153548856.PNG)

- **注意单元和字单元的区别。**

## 栈

8086CPU提供出栈和入栈的功能。push和pop,比如push ax 表示将寄存器ax中的数据送入栈中。**8086CPU的入栈和出栈操作都是以字为单位进行的。（寄存器的对象必须是16位的）**

8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在 SS 中，偏移地址存放在 SP中。**任意时刻，SS：SP 指向栈顶元素。**

push指令的执行步骤：

1. SP=SP-2；
2. 向SS：SP指向的字单元中送入数据

pop指令的执行步骤：

1. 从SS：SP指向的字单元读取数据
2. SP=SP+2；

存在以下几种形式：

push 寄存器

pop 寄存器

push 段寄存器

pop 段寄存器

**push 内存单元   （注意：ds取段地址）**

**pop 内存单元**

- **注意：push、pop等栈操作指令，修改的只是SP。也就是说：栈顶的变化范围最大为 0~FFFFH。**
- 8086CPU只记录栈顶，栈空间的大小我们要自己管理。
- push、pop实质上是一种内存传送指令，注意它们的灵活应用。



