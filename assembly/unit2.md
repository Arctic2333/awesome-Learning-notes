# unit 2

寄存器是CPU中程序员可以用指令读写的部件。

程序员通过改变各种寄存器中的内容来实现对CPU的控制。

8086CPU中的所有寄存器都是16位的。但为保证兼容，8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用：**AX可分为AH、AL**……

[^AH]: H:High  **高八位寄存器**
[^AL]: L：Low 低八位寄存器

8086CPU可以一次性处理以下两种尺寸的数据：

- 字节：Byte，一个字节由8bit组成，可以存在8位寄存器中

- 字：word，一个字由两个字节组成，分别是高位字节和低位字节，自然就存在高8位寄存器和低8位寄存器中。

  

  ### 数制的讨论

*十六进制数的一位相当于二进制数的四位。***如0100111000100000可表示成4（0100）、E（1110）、2（0010）、0（0000）四位十六进制数。** 

- **从左往右4位4位写，不够补零**

- 由此可知：八进制数的一位相当于二进制数的三位。

- 在十六进制表示的数据后面加H，在二进制表示的数据后面加B，十进制表示的数后面什么都不用加。

  - [x] 汇编指令或者寄存器的名称不区分大小写。

  

  **例子分析：当 AX中数据为8826H BX中为8826GH 执行 add ax,bx 后AX内的数据为多少？**

  **相加所得的值为：1044CH，但ax为16为寄存器，只能放4位16进制数的数据，所以最高位的1不能在ax中保存，ax中的数据为044CH。**

  **例子2分析：当AX为00C5H  执行add al,93H 后AX内的数据为多少？**

  **相加所得的值为：158H，但是al为8位寄存器，只能存放两个十六进制的数据，所以最高位的1丢失，ax中的数据为：0058H（丢失，指的是进位值不能在8位寄存器中保存，但是CPU并不是真的丢弃进位值）**

- 注意：当al作为一个独立的8位寄存器来使用的，和ah没有关系，CPU在执行这条指令时认为ah和al是两个不相干的寄存器，进位值不会放在ah。



#### 在进行数据传送和运算时，要注意指令的两个操作对象的位数应当是一致的。

### 16位结构的CPU

概括地讲，16位结构（16位机，字长为16位等常见说法，与16位结构的含义相同）描述了一个CPU具有下面几方面结构特性：

1.运算器一次最多可以处理16位的数据结构

2.寄存器的最大宽度为16位

3.寄存器和运算器之间的通路为16位

### 8086CPU给出物理地址的方法

8086CPU有20位地址总线，可以传送20位地址（5位16进制数），寻址能力达到1MB。那么怎么在16位结构中达到20位地址的呢？

8086CPU采用一种在内部用16位地址合成的方法来形成一个20位的物理地址。

![](https://images2015.cnblogs.com/blog/1100576/201704/1100576-20170413084037142-1331059047.png)

 如上图2.6所示，当8086要读写内存时： 

![](https://images2015.cnblogs.com/blog/1100576/201704/1100576-20170413084256189-1123841669.png)

![](https://images2015.cnblogs.com/blog/1100576/201704/1100576-20170413084333955-1585568285.png)

### 讨论：

 **段地址*16还有一个更为常用的说法是左移4位。**

**一个数据的二进制形式左移1位，相当于该数据乘以2，左移N位，相当于该数据乘以2的N次方。**

**一个数据的十六进制形式左移1位，相当于乘以16，**

**一个十进制左移1位，相当于乘以10，**

**一个X进制的左移1位，相当于乘以X。** 



### “段地址*16+偏移地址=物理地址”的本质含义

CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

![](https://images2015.cnblogs.com/blog/1100576/201704/1100576-20170413090000111-689161726.png)

![](https://images2015.cnblogs.com/blog/1100576/201704/1100576-20170413090054345-353883960.png)

![](https://images2015.cnblogs.com/blog/1100576/201704/1100576-20170413090120455-1102932897.png)

8086只能一次只能传输4位数据，前面那个段地址和偏移地址的方式就可以得到解释 



## 段的概念

 若干地址连续的内存单元看作一个段，用段地址*16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。

**注意：**

- 段地址*16必然是16的倍数，所以一个段的起始地址一定是16的倍数；
- 偏移地址为16位，16位地址的寻址能力为64kb，所以一个段的长度最大为64kb。
- CPU可以用不同的段地址和偏移地址形成同一个物理地址
- 内存并没有分段，段的划分来自于CPU
- **物理地址：SA*16+EA（SA：段地址 EA：偏移地址）**
- 偏移地址为16位时，变化范围：0~FFFFH



### CS和IP

CS和IP是8086CPU中两个关键的寄存器。CS为代码段寄存器，IP为指令指针寄存器。

在8086pc机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行。也就是说**任意时刻，CPU将CS：IP指向的内容当作指令执行。**

8086CPU工作流程：

1. CS和IP的内容传到地址加法器：CS*16+IP
2. 输入输出控制电路
3. 地址总线输出物理地址（5位16进制数）
4. 取数据送入指令缓冲器同时IP=IP+所读取指令的长度
5. 执行。转到步骤（1）

![]( https://img-blog.csdnimg.cn/20200115121727753.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTUwODkw,size_16,color_FFFFFF,t_70 )



### 修改CS和IP

最简单修改CS、IP的指令：**jmp指令**

同时修改CS、IP的内容，可以使用**“jmp 段地址:偏移地址”**的指令

jmp 2AE3:3；执行后CS=2AE3H,IP=0003H，CPU将从2AE33H处读取指令。

**若仅想修改IP的内容，可以使用“jmp 某一合法寄存器 ”**

jmp ax 执行前 ax = 1000H CS = 2000H IP =0003H

​			 执行后ax = 1000H CS = 2000H IP = 1000H



### 命令：

- 查看、修改CPU寄存器的内容：R命令
- 查看内存中的内容：D命令
- 修改内存中的内存：E命令（可以写入数据、指令、在内存中，它们实际没有区别）
- 将内存中的内容解释为机器指令和对应的汇编指令：U命令
- 执行CS：IP指向的内存单元处的指令：T命令
- 以汇编指令的形式向内存中写入指令：A命令

**注意：**

- 从地址0~9FFFF的内存单元中读取数据，实际上是在读取主随机存储器中的数据。
- 向地址A0000~BFFFF的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示屏上。
- 向地址C0000~FFFFF的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。